#!/bin/bash
buffermaker_version="0.11.6"
## Buffermaker
# Pure bash tui framework (wip)

shopt -s lastpipe # For syntax highlighting
shopt -s extglob # Ensure advanced pattern matching is available
shopt -s checkwinsize && (:;:) # Enable and then trigger a terminal size refresh

declare -r DEFIFS="$IFS"
declare -A highlight faces faces_raw options charmap hooks resources
declare -A keys_global
declare -a k_hex buffers_l modes=('keys_global')
declare -n buffer bf_s bf_e bf_d
declare -i ismenu comment current_count
declare reset readin

source bxcommon

function load-default-config {
	## Configuration
	#		The magic :: function
	#			:: sets value to option depending on current context:
	#				set-options ‚Üí define-options() ‚Üí ass. array options
	#				global-set ‚Üí global-set-key ‚Üí define-key global ‚Üí as. ar. keys_global
	#				add-mode ‚Üí local-set-key ‚Üí define-key <keys> ‚Üí a. a. keys_<keys>
	#					mode-options ‚Üí local-set-mode-option ‚Üí define-mode-option ‚Üí a. a. key_options_<keys>
	#				set-alias ‚Üí add-alias ‚Üí a. a. alias
	#				add-menu ‚Üí local-set-menu ‚Üí define-menu <menu> ‚Üí menu_<menu>_0 & menu_<menu>_1
	#				set-highlight ‚Üí add-highlight ‚Üí a. a. highlight
					  
	options=(
		[mouse]=0
		[todonote]=0
		[line-number-mode]=0
		[empty-line-char]=''
		[tty-linuxfb]=1 # enable truecolor support for framebuffer
		[full-redraw]=0 # redraws whole buffer, can fix artifacting in linuxfb at cost of performance
		[esc-to-meta]=0
	)
		
	## Key bindings configuration
	#		A keybinding is defined via either
	#		global-set; :: ... ... or add-mode <mode>; :: ... ...
	#		:: <key> <command>
	#			<key> is defined either via
	#				Hexadecimal format (with ' 0' added as suffix).
	#				Name of key like '[<key>]'
	#				Emacsy "$(kbd <key> )" (<key> being something like C-s M-e ...)
	#			The name of key and $(kbd) get translated into hex. format on startup.
	#
	#			mode-options sets magic :: to defining mode options
	#			:: option value

	add-mode empty
		mode-options
			:: else :
			:: disable-global 1

	add-mode menu
		:: '[up]' menu.up
		:: "$(kbd k)" menu.up
		:: 'C-p' menu.up
		:: '[down]' menu.down
		:: "$(kbd j)" menu.down
		:: 'C-n' menu.down
		:: 'RET' menu.select
		mode-options
			:: else menu.exit
			:: disable-global 1

	add-mode basic
		:: '[left]' format-left
		:: '[up]' format-up
		:: '[right]' format-right
		:: '[down]' format-down
		:: RET link-enter
		:: C-c die
		mode-options
			:: else :

	## Faces
	#		Defined in escape codes
	#		Helper functions:
	#			:weight
	#				normal
	#				bold
	#			:slant
	#				normal
	#				italic
	#           :underline
	#               t (enables)
	#               nil (do nothing)
	#			:background & :foreground
	#				either hex. colour, colour name, or c<index> for 256 indexed colours
	#		See extensions/gruvboxdark for another example
	default_faces=(
		reset '\e[m'
		default "$(:weight normal)"
		border-highlight "$(:mode inverse)"
		border-shadow "$(:mode inverse :foreground gray)"
		menu "$(:background yellow :foreground black)"
		menu-divider "$(:underline t)"
		menu-highlight "$(:weight bold :underline t)"
		menu-enabled "$(:background yellow :foreground black)"
		menu-selected "$(:background light-yellow :foreground black :weight bold)"
		checkbox-disabled "$(:foreground light-gray)"
		checkbox-enabled "$(:foreground yellow :weight bold)"
		action "$(:foreground light-blue)"
		button "$(:mode inverse :underline t)"
		link "$(:underline t :foreground light-blue)"
		link-highlight "$(:weight bold :underline t :foreground light-blue)"
		title "$(:weight bold)"
		alt "$(:slant italic)"
		highlight "\e[4m$(:weight bold)"
		accent "$(:foreground yellow)"
		background-highlight "$(:background black)"
		dim "$(:weight dim)"
		divider "$(:foreground gray)"
		name "$(:foreground magenta)"
		hint "$(:foreground light-yellow)"
		hint-highlight "$(:underline t :foreground light-yellow)"
		line-number "$(:foreground gray)"
		line-number-empty "$(:weight dim :foreground gray)"
		line-number-current-line "$(:weight bold :foreground light-red)"
		tab-face "$(:weight dim :foreground gray)"
		region "$(:weight bold :background gray)"
		minibuffer-prompt "$(:weight normal)"
		#
		TODO "$(:background magenta)"
		NOTE "$(:background gray)"
		# common colors for format stuff
		black      '\e[30m' gray          '\e[90m'
		red        '\e[31m' light-red     '\e[91m'
		green      '\e[32m' light-green   '\e[92m'
		yellow     '\e[33m' light-yellow  '\e[93m'
		blue       '\e[34m' light-blue    '\e[94m'
		magenta    '\e[35m' light-magenta '\e[95m'
		cyan       '\e[36m' light-cyan    '\e[96m'
		light-gray '\e[37m' white         '\e[97m'

		bg-black      '\e[40m' bg-gray          '\e[100m'
		bg-red        '\e[41m' bg-light-red     '\e[101m'
		bg-green      '\e[42m' bg-light-green   '\e[102m'
		bg-yellow     '\e[43m' bg-light-yellow  '\e[103m'
		bg-blue       '\e[44m' bg-light-blue    '\e[104m'
		bg-magenta    '\e[45m' bg-light-magenta '\e[105m'
		bg-cyan       '\e[46m' bg-light-cyan    '\e[106m'
		bg-light-gray '\e[47m' bg-white         '\e[107m'
	)
	load-theme default_faces

	resources=(
		[&]='&'
		[line]='‚îÄ'
		[bold-line]='‚îÅ'
		[column]='‚îÇ'
		[bold-column]='‚îÉ'
		[angle-down-right]='‚îå'
		[bold-angle-down-right]='‚îè'
		[angle-down-left]='‚îê'
		[bold-angle-down-left]='‚îì'
		[angle-up-right]='‚îî'
		[bold-angle-up-right]='‚îó'
		[angle-up-left]='‚îò'
		[bold-angle-up-left]='‚îõ'
		[double-line]='‚ïê'
		[double-column]='‚ïë'
		[double-angle-down-right]='‚ïî'
		[double-angle-down-left]='‚ïó'
		[double-angle-up-right]='‚ïö'
		[double-angle-up-left]='‚ïù'
		[item]='*'
		[item-number]='.'
		[tab]='    '
		[checkbox-disabled]='[ ]'
		[checkbox-enabled]='[x]'
	)
}

## syntaxy sugar sugary syntax
function @ifs { IFS="$DEFIFS"; }

function ::
case "$_last_add" in
	add-menu) local-set-menu "$@";;
	set-highlight) add-highlight "$@";;
	global-set) global-set-key "$@";;
	set-options) define-option "$@";;
	add-mode) local-set-key "$@";;
	mode-options) local-set-mode-option "$@";;
	set-buffer) local-set-buffer-data "$@"
esac

## focus set magic # function
function focus {
	_last_add="$1"
}

function declare-buffer {
	_last_add='set-buffer'
	set-buffer "${1}" # name
	buffers_l+=("$current_buffer")
	last_line=1
	declare -Ag "${current_buffer}_bf_t"
	declare -Ag "${current_buffer}_bf_h"
	declare -Ag "${current_buffer}_bf_d"
	bf_d=(
		# some sane default values
		[line]=0
		[base]=1
		[column]=0
		[modified]=0
		[loc-x]=1
		[loc-y]=1
		[size-x]=$COLUMNS
		[size-y]=$LINES
	)
}

## local-set-buffer-data
# set bf_d[] array of currently \"focused\" buffer
function local-set-buffer-data {
	while [ -n "$2" ]; do
		bf_d["$1"]="$2"
		shift 2
	done
}

## [auto] Checks bf_d[] array and set\'s needed missing values automatically
function [auto] {
	[ -z "${bf_d[loc-x]}" ] && bf_d[loc-x]=1
	[ -z "${bf_d[loc-y]}" ] && bf_d[loc-y]=1
	[ -z "${bf_d[size-x]}" ] && bf_d[size-x]=$COLUMNS
	[ -z "${bf_d[size-y]}" ] && bf_d[size-y]=$((LINES - 1))
	[ -z "${bf_d[syntax]}" ] && set-syntax 
}


## fn Shorthand for one line functions
function fn {
	[ -z "$*" ] && exit 1 # error if empty
	local name="$1"
	shift
	eval "function $name { $@; }"
}
	
## kbd Converts Emacs like key notation into hex.
function kbd {
	local -i i=0
	local out
	local in
	local -i ch=1
	# Surely there is better solution...
	ch=0
	case "${1:0:2}" in
		M-) in="${1:2:1}";;
		*) in="$1"
	esac
	((ch)) && return
	echo "$in" | {
		while read -rsn1; do
			out+="$(printf "%x\n" "'${in:$i}") "
			((i++))
		done
	}
	out=${out::-1}
	printf '%s' "${out}"
}

## define-key defines keybinding
#     '$1' can be either:
#     '[function-key]'
#     '[arrow-key]'
#     '[prior | next]'
#     'RET'
#     'DEL'
#     '[delechar]'
#     'hex code ending with 0'
function define-key {
	local -n keys="keys_$1"
	case "$2" in
		#control
		C-a) keys[1 0]="$3" ;; C-b) keys[2 0]="$3" ;;
		C-c) keys[3 0]="$3" ;; C-d) keys[4 0]="$3" ;;
		C-e) keys[5 0]="$3" ;; C-f) keys[6 0]="$3" ;;
		C-g) keys[7 0]="$3" ;; C-h) keys[8 0]="$3" ;;
		C-i) keys[9 0]="$3" ;; C-j) keys[a 0]="$3" ;;
		C-k) keys[b 0]="$3" ;; C-l) keys[c 0]="$3" ;;
		C-m) keys[d 0]="$3" ;; C-n) keys[e 0]="$3" ;;
		C-o) keys[f 0]="$3" ;; C-p) keys[10 0]="$3";;
		C-q) keys[11 0]="$3";; C-r) keys[12 0]="$3";;
		C-s) keys[13 0]="$3";; C-t) keys[14 0]="$3";;
		C-u) keys[15 0]="$3";; C-v) keys[16 0]="$3";;
		C-w) keys[17 0]="$3";; C-x) keys[18 0]="$3";;
		C-y) keys[19 0]="$3";; C-z) keys[1a 0]="$3";;
		#function keys
		'[f1]') keys[1b 4f 50 0]="$3";;
		'[f2]') keys[1b 4f 51 0]="$3";;
		'[f3]') keys[1b 4f 52 0]="$3";;
		'[f4]') keys[1b 4f 53 0]="$3";;
		'[f5]')  keys[1b 5b 31 35 7e 0]="$3";;
		'[f6]')  keys[1b 5b 31 37 7e 0]="$3";;
		'[f7]')  keys[1b 5b 31 38 7e 0]="$3";;
		'[f8]')  keys[1b 5b 32 39 7e 0]="$3";;
		'[f9]')  keys[1b 5b 32 30 7e 0]="$3";;
		'[f10]') keys[1b 5b 32 31 7e 0]="$3";;
		'[f11]') keys[1b 5b 32 33 7e 0]="$3";;
		'[f12]') keys[1b 5b 32 34 7e 0]="$3";;
		#arrow keys
		'[left]')  keys[1b 5b 44 0]="$3";;
		'[up]')    keys[1b 5b 41 0]="$3";;
		'[right]') keys[1b 5b 43 0]="$3";;
		'[down]')  keys[1b 5b 42 0]="$3";;
		#pg up & down
		'[prior]') keys[1b 5b 36 7e 0]="$3";;
		'[next]')  keys[1b 5b 35 7e 0]="$3";;
		#return
		'RET') keys[a 0]="$3";;
		#backspace & delete
		'DEL') keys[7f 0]="$3";;
		'[deletechar]') keys[1b 5b 33 7e 0]="$3";;
		'ESC') keys[1b 0 0]="$3";;
		'[deletechar]') keys[1b 5b 33 7e 0]="$3";;
		*) keys["$2"]="$3"
	esac
}

## local-set-key
# Sets keybinding of lastly defined mode
# See define-key for details
fn local-set-key 'define-key "$_last_keys" "$@"'

## global-set-key
# Sets keybinding of global mode
# See define-key for details
fn global-set-key 'define-key global "$@"'

## define-mode-option
# Sets option of mode '$1'
function define-mode-option {
	local -n ko="key_options_$1"
	ko["$2"]="$3"
}

## local-set-mode-option See define-mode-option
fn local-set-mode-option 'define-mode-option "$_last_keys" "$@"'

## mode-options Brings mode-options of lastly defined mode into \"focus\"
fn mode-options '_last_add="mode-options"'

## add-highlight Sets highlighting mode '$1' for file types '$2...'
function add-highlight {
	local name="$1"
	shift
	for i in "$@"; {
		highlight["$i"]="$name"
	}
}

## set-alias Brings into \"focus\" highlight setting
fn set-highlight '_last_add=set-highlight'

## clear-screen clears screen
fn clear-screen "printf '\033c'"

## add-mode
# Adds keybing mode
function add-mode {
	_last_keys="$1"
	_last_add='add-mode'
	modes+=("keys_$1")
	declare -Ag "keys_$1"
	declare -Ag "key_options_$1"
}

## global-set Brings into \"focus\" global mode
fn global-set '_last_add=global-set'

## define-option Defines options[] buffer
fn define-option 'options["$1"]="$2"'

## set-options Brings into \"focus\" options setting
fn set-options '_last_add=set-options'

function menu.add {
	# create new menu function & array
	eval "function @menu:${1} { menu $1; }"
	declare -ag "menu_${1}_0"
	declare -ag "menu_${1}_1"
	declare -ag "menu_${1}_2"

	local -n menu_0="menu_${1}_0"
	local -n menu_1="menu_${1}_1"
	local -n menu_1="menu_${1}_2"

	local -i c=-1
	local type
	
	local -n menu="$1"
	for i in "${menu[@]}"; do
		case "$i" in
			't:'|'text:')
				type=text
				((c++))
				continue;;
			'c:'|'cmd:'|'command:')
				type=command
				continue;;
			'f:'|'face:')
				type=face
				continue	
		esac
		case "$type" in
			'text')
				menu_0[c]+=" $i"
				;;
			'command')
				menu_1[c]+="$i "
				;;
			'face')
				menu_2[c]+="$i"
		esac
	done
	menu.layout "$1"
}
function menu.layout {
	local -n menu_0="menu_${1}_0"
	local -i max=0
	for i in "${menu_0[@]}"; do
		((${#i} > max)) && max="${#i}"
	done
	for i in "${!menu_0[@]}"; do
		for ((l=$((max - ${#menu_0[i]})) + 1; l>0; l--)); do
			menu_0[i]+=' '
		done
	done
}

## load-theme Loads theme from array
function load-theme {
	local -i t=0
	local k
	local -n theme="$1"
	for i in "${theme[@]}"; {
		((t==0)) && {
			k="$i"
			t=1
		} || {
			faces["$k"]="$i"
			faces_raw["$k"]="$(printf '%b' "$i")"
			t=0
		}
	}
	((t)) && errno=1 die
			 
}

## rest of this garbageware

## refresh Refreshes buffer
# 'clears screen, reset syntax, redraws'
# 'See <a> doc-goto clear-screen : <f> link clear-screen </f> </a> for more info.'
function refresh {
	clear-screen
	bf_s=''
	redraw
}

## switch-mode
# Change current mode of buffer into '$1'
function switch-mode {
	bckmode="${bf_d[mode]}"
	bf_d[mode]="$1"
}

## mode-back
# Restores previous mode
function mode-back {
	bf_d[mode]="$bckmode"
	unset bckmode
}

## read-command
# Works like normal "'read'" but for bottom commanline
function read-command {
	local -i loc
	[ -n "$4" ] && loc="$4" || loc=$((bf_d[size-y] + bf_d[loc-y])) 
	printf '\e[%s;0H' "$loc"
	printf '\e[?25h'
	read -re -p "$1" -i "$3" "$2" || return 1
}

## base-name
# Basically equivalent to the "'basename'" coreutil		
function base-name
	for file in "$@"; {
		file="${file%/}"
		printf '%s\n' "${file##*/}"
	}

### TODO: make this make sense

## make-render Creates syntax highlighting for currently visible lines
function make-render {
	make-render-area "${bf_d[base]}" $((bf_d[base] + bf_d[size-y] + bf_d[loc-y]))
}

## make-render-area
# Creates syntax highlighting for lines from '$1' to '$2'
function make-render-area {
    local -i line="$1"
	local -i syntaxline=$line
	local -n linearray="${current_buffer}_syntax${syntaxline}"
	linearray=()
	bckeIFS="${IFS}"
	IFS=
	for ((l=syntaxline;l<${2};l++)); do
		((l > $2)) && break
		local -n linearray="${current_buffer}_syntax${syntaxline}"
		linearray=()
		bf_s[syntaxline]="${current_buffer}_syntax${syntaxline}"
		((syntaxline++))
		line="$l"
		local -a s
		
		case "${bf_d[render-type]}" in
			'per-char') make-render-line-loop-char;;
			'per-word') make-render-line-loop;;
			*) make-render-line-loop
		esac
	done
	IFS="$bckeIFS"
}
	
## make-render-line
# Syntax highlights single line '$1'
# Defaults to currently selected line if no argument is passed
function make-render-line {
	local -i line=${1:-bf_d[line]}
	local -i syntaxline=$line
	local -n linearray="${current_buffer}_syntax${syntaxline}"
	bf_s[syntaxline]="${current_buffer}_syntax${syntaxline}"
	linearray=()
	bckeIFS="${IFS}"
	IFS=
	local -a s
	
	case "${bf_d[render-type]}" in
		'per-char') make-render-line-loop-char;;
		'per-word') make-render-line-loop;;
		*) make-render-line-loop
	esac
	IFS="$bckeIFS"
}

function make-render-line-loop {
	local -i comment=0
	local -i skip_next_space=0
	
	local word=''
	bf_e[line]=''

	for _link in ${bf_c[line]}; do
		unset "$_link"
	done
	unset bf_c[line]
		
	column=0
	IFS=' '
	while read -rs word; do
		IFS=''
		syntax-word
		IFS=' '
	done  <<< "${buffer[line]}"
}

## make-render-line-loop
# Backend for make-render-area \& make-render-line
# Also creates bf_e charmap for movenment
#     "Tab is 't'"
#     "Space is 's'"
#     "Any unmaped char is '0'"
function make-render-line-loop-char {
	local -i comment=0
	local -i skip_next_space=0
	local word=''
	bf_e[line]=''

	for _link in ${bf_c[line]}; do
		unset "$_link"
	done
	unset bf_c[line]
		
	column=0
	
	while read -rsn1 char; do	
		case "$char" in
			' ')
				syntax-word
				word=''
				((skip_next_space==1)) && skip_next_space=0 && continue
				bf_e[line]+='s'
				face-no-expand "${facename:-${bf_d[background]:-default}}" ' '
				((column++));;
			'	')
				syntax-word
				word=''
				local -i i
				for ((i = ${#resources[tab]}; i > 0 ; i--)); do
					bf_e[line]+="${charmap[	]}"
				done
				face-no-expand tab-face "${resources[tab]}"
				((column+=${#resources[tab]}));;
			'')
				syntax-word
				word=''
				skip_next_space=0
				face-no-expand "${bf_d[background]:-default}" ' '
				newline=1 # tell syntax functions that the previous char was newline # used for format thing
				return;;
			*)
				word+="${char}"
		esac
	done  <<< "${buffer[line]}"
}

## syntax-word
# Decides what a word should highlighted as:
#     'If todonote option is enabled, highlight "NOTE:" & "TODO:"'
#     'If the word is supposed to be comment highlight it as it'
#     'Else pass it to current syntax function'
function syntax-word {
	(("${options[todonote]}"==1)) && {
		case "$word" in
			'NOTE:') face NOTE "${word}"; return ;;
			'TODO:') face TODO "${word}"; return ;;
		esac
	}
	((comment)) && set-face font-lock-comment-face ||
		"${bf_d[syntax]}"
	((bf_d[syntax-exec])) || face "$syntax_face" "$word" # s_ex controls syntax extended
}

## face
# Add highlighted word to multidimensional nonsense "'bf_s'" arry
function face {
	IFS=' '
	[[ "$2" =~ ${2//?/(.)} ]]
	linearray+=("${faces_raw[reset]}${faces_raw[${1}]}${BASH_REMATCH[@]:1}")
	IFS=''
	for ((iw=0; iw < ${#2}; iw++)); do
		bf_e[line]+='0'
	done
}

## face-no-expand
# Add highlighted word to multidimensional nonsense "'bf_s'" arry without adding anything to bf_e[] array
function face-no-expand {
	IFS=' '
	[[ "$2" =~ ${2//?/(.)} ]]
	linearray+=("${faces_raw[reset]}${faces_raw[${1}]}${BASH_REMATCH[@]:1}")
	IFS=''
}

## set-face Sets face for syntax highlighting
fn set-face 'syntax_face="$1"'

## size-full
# Sets size of buffer to be fullscreen
function size-full {
	bf_d+=(
		[loc-x]=1
		[loc-y]=1
		[size-x]=$COLUMNS
		[size-y]=$LINES
	)
}

## set-buffer
# Switch to buffer \$1 
function set-buffer {
	current_buffer="$1"
	declare -ng buffer="${current_buffer}_buffer" # source
	declare -ng bf_s="${current_buffer}_bf_s" # syntax
	declare -ng bf_e="${current_buffer}_bf_e" # charmap
	declare -ng bf_d="${current_buffer}_bf_d" # data
	declare -ng bf_c="${current_buffer}_bf_c" # commands/objects
	declare -ng bf_h="${current_buffer}_bf_h" # hooks
	declare -ng bf_t="${current_buffer}_bf_t" # tmp cache
}
function switch-buffer {
	set-buffer "$1"
	redraw
}

## add-to-list
# Adds a buffer into currently active buffer list
function add-to-list {
	buffers_l+=("$current_buffer")
}

## clear-buffer
# Empties buffer bf_s bf_e \& bf_d
function clear-buffer {
	buffer=()
	for l in "${bf_s[@]}"; {
		unset "$l"
	}
	bf_s=()
	bf_e=()
	for l in "${bf_c[@]}"; {
		unset "$l"
	}
	bf_c=()
}

## list-directory
# Basically like ls command 
function list-directory {
	((options[display-dotfiles]==1)) && shopt -s dotglob
	((options[display-dotfiles]==0)) && shopt -u dotglob
	printf '..\n'
	printf '%s\n' *
}

## current-time
# Basically like coreutil "'date'"
fn current-time 'printf "%($1)T\\n"'

## goto Load array into buffer
function goto {
	clear-buffer
	bf_d[line]=1
	bf_d[column]=0
	copy-array "$1" buffer
	redraw
}
function syntax-none {
	set-face "${bf_d[background]:-default}"
}


########################################################################################################################
function format-include {
	_buffer="$current_buffer"
	for bf in "${format_include_buffers[@]}"; do
		set-buffer "$bf"
		redraw
	done
	set-buffer "$_buffer"
}

function syntax-format {
	((skip_word==1)) && {
		skip_next_space=1
		[ "$word" = '-->' ] && skip_word=0
		return
	}
	[ "$word" = '<!--' ] && {
		skip_next_space=1
		skip_word=1
		return
	}

	((insert_bf==1)) && {
		skip_next_space=1
		[ "$word" = '>>' ] && {
			insert_bf=0
			format_include_buffers+=("${insert_arg[1]}")
			insert_arg=()
			return
		}
		insert_arg+=("$word")
		return
	}
	[ "$word" = '<<' ] && {
		skip_next_space=1
		insert_bf=1
		insert_arg=()
		return
	}

	
	((newline==1)) && {
		bf_t[ichar]="${bf_t[indent_spaces]}"
		bf_t[iexp]="${bf_t[indent_spaces_e]}"
	}
	((newline==0)) && {
		bf_t[ichar]=
		bf_t[iexp]=
	}

	((escape==2)) && {
		escape=1
		facename="$word"
		skip_next_space=1
		return
	}
	((escape==1)) && {
		escape=0
		face "$facename" "${bf_t[ichar]}$word"
		return
	}
	[ "$word" = '<\>' ] && {
		escape=1
		skip_next_space=1
		facename='unknown'
		return
	}
	[ "$word" = '<[>' ] && {
		escape=2
		skip_next_space=1
		return
	}
	
	((variable==1)) && {
		variable=0
		word="${!word}"
	}
	[ "$word" = '<v>' ] && {
		variable=1
		varname=
		skip_next_space=1
		return
	}

	[ "$word" = '</u>' ] && {
		upper=0
		skip_next_space=1
		return
	}
	[ "$word" = '<u>' ] && {
		upper=1
		skip_next_space=1
		return
	}
	[ "$word" = '</f>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		unset facename
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	[ "$word" = '</f->' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		skip_next_space=1
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	((facedef==1)) && {
		skip_next_space=1
		facedef=0
		facename="$word"
		return
	}
	[ "$word" = '<f>' ] && {
		bckfacename="$facename"
		skip_next_space=1
		facedef=1
		return
	}
	[ "$word" = '<-f>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		bckfacename="$facename"
		skip_next_space=1
		facedef=1
		return
	}
	
	[ "$word" = '</h>' ] || [ "$word" = '</h3>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		unset facename
		upper=0
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	[ "$word" = '<h>' ] || [ "$word" = '<h3>' ] && {
		bckfacename="$facename"
		skip_next_space=1
		facename=title
		upper=1
		return
	}

	[ "$word" = '</b>' ] || [ "$word" = '</strong>' ] || [ "$word" = '</i>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		unset facename
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	[ "$word" = '<b>' ] && {
		bckfacename="$facename"
		skip_next_space=1
		facename=title
		return
	}
	[ "$word" = '<i>' ] && {
		bckfacename="$facename"
		skip_next_space=1
		facename=alt
		return
	}
	
	[ "$word" = '<strong>' ] && {
		bckfacename="$facename"
		skip_next_space=1
		facename=highlight
		return
	}
	
	((sethighlight==2)) && {
		sethighlight=1
		skip_next_space=1
		tmp_sex="$word"
		return
	}
	((sethighlight==1)) && {
		sethighlight=0
		skip_next_space=1
		bf_d[syntax-exec]="$tmp_sex"
		bf_d[syntax]="syntax-$word"
		return
	}
	[ "$word" = '<change-syntax>' ] && {
		skip_next_space=1
		sethighlight=2
		return
	}
	[ "$word" = '<tab>' ] || [ "$word" = '<->' ] && {
		skip_next_space=1
		face-no-expand tab-face "${resources[tab]}"
		for ((if=0; if< ${#resources[tab]}; if++)) {
			bf_e[line]+='t'
			((column++))
		}
		return
	}
	[ "$word" = '</indent>' ] && {
		bf_t[indent_spaces]=
		bf_t[indent_spaces_e]=
		return
	}
	((bf_t[indent]==1)) && {
		bf_t[indent]=0
		skip_next_space=1
		bf_t[indent_spaces]=
		bf_t[indent_spaces_e]=
		bf_t[indent_spaces_f]=tab
		case "$word" in
			'&tab')
				bf_t[indent_spaces]="${resources[tab]}"
				for ((if=0; if< ${#resources[tab]}; if++)) {
					bf_t[indent_spaces_e]+='t'
				}
				return
		esac
		for ((if=0; if< word; if++)) {
			bf_t[indent_spaces]+=' '
			bf_t[indent_spaces_e]+='s'
		}
		return
	}
	[ "$word" = '<indent>' ] && {
		bf_t[indent]=1
		skip_next_space=1
		return
	}
	((link==2)) && {
		[ "$word" = ':' ] && {
			((
				skip_next_space=1,
				link=1
			))
			return
		}
		skip_next_space=1
		linkfn+="$word "
		return
	}
	[ "$word" = '</a>' ] && {
		((lc++))
		((column--))
		link=0
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		bf_c[line]+="bf_c_${lc}_${current_buffer} "
		declare -Ag "bf_c_${lc}_${current_buffer}"
		local -n bf_c_line="bf_c_${lc}_${current_buffer}"
		bf_c_line=(
			[start]="$lsx"
			[end]=$((column - 1))
			[exec]="$linkfn"
		)
		return
	}
	[ "$word" = '<a>' ] && {
		((
			link=2,
			lsx=column,
			skip_next_space=1
		))
		linkfn=
		return
	}
	((facelink==2)) && {
		[ "$word" = ':' ] && {
			((
				skip_next_space=1,
				facelink=1
			))
			facename='link'
			return
		}
		skip_next_space=1
		linkfn+="$word "
		return
	}
	[ "$word" = '</link>' ] && {
		((lc++))
		((column--))
		facelink=0
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		bf_c[line]+="bf_c_${lc}_${current_buffer} "
		declare -Ag "bf_c_${lc}_${current_buffer}"
		local -n bf_c_line="bf_c_${lc}_${current_buffer}"
		bf_c_line=(
			[start]="$lsx"
			[end]=$((column - 1))
			[exec]="$linkfn"
		)
		unset facename
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	[ "$word" = '<link>' ] && {
		((
			facelink=2,
			lsx=column,
			skip_next_space=1
		))
		linkfn=
		return
	}
	
	((object==1)) && {
		skip_next_space=1
		[ "$word" = 'text:' ] && {
			object=0
			set_obj=0
			return
		}
		[ "$word" = 'select:' ] && { set_obj=1; obj_select=; return; }
		[ "$word" = 'id:' ] && { set_obj=2; obj_id=; return; }
		[ "$word" = 'left:' ] && { set_obj=3; obj_left=; return; }
		[ "$word" = 'up:' ] && { set_obj=4; obj_up=; return; }
		[ "$word" = 'right:' ] && { set_obj=5; obj_right=; return; }
		[ "$word" = 'down:' ] && { set_obj=6; obj_down=; return; }

		((set_obj==1)) && obj_select+="$word "
		((set_obj==2)) && obj_id+="$word "
		((set_obj==3)) && obj_left+="$word "
		((set_obj==4)) && obj_up+="$word "
		((set_obj==5)) && obj_right+="$word "
		((set_obj==6)) && obj_down+="$word "
		return
	}
	[ "$word" = '</o>' ] && {
		((lc++))
		((column--))
		link=0
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		bf_c[line]+="bf_c_${lc}_${current_buffer} "
		declare -Ag "bf_c_${lc}_${current_buffer}"
		local -n bf_c_line="bf_c_${lc}_${current_buffer}"
		bf_c_line=(
			[start]="$lsx"
			[end]=$((column - 1))
			[exec]="$obj_select"
			[id]="$obj_id"
			[left]="$obj_left"
			[up]="$obj_up"
			[right]="$obj_right"
			[down]="$obj_down"
		)
		return
	}
	[ "$word" = '<o>' ] && {
		((
			object=1,
			lsx=column,
			skip_next_space=1
		))
		obj_id=
		obj_text=
		obj_select='true'
		obj_left='backward-char'
		obj_up='previous-line'
		obj_right='forward-char'
		obj_down='next-line'
		set_obj=0
		return
	}
	((bf_t[checkbox]==1)) && {
		bf_t[checkbox]=0
		local -n state="$word"
		[ -z "$state" ] && {
			state=0
		}
		local display=
		bckfacename="$facename"
		case "$state" in
			'1')
				facename=checkbox-enabled
				display="${resources[checkbox-enabled]}";;
			*)
				facename=checkbox-disabled
				display="${resources[checkbox-disabled]}"
		esac
		((lc++))
		((column--))
		bf_c[line]+="bf_c_${lc}_${current_buffer} "
		declare -Ag "bf_c_${lc}_${current_buffer}"
		local -n bf_c_line="bf_c_${lc}_${current_buffer}"
		bf_c_line=(
			[start]=$((column))
			[end]=$((column + ${#display}))
			[exec]="toggle-checkbox $line $word"
		)
		word="${display}"
	}
	[ "$word" = '<ch>' ] && {
		((
			bf_t[checkbox]=1,
			skip_next_space=1
		))
		return
	}
	[ "$word" = '</ch>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		((column--))
		unset facename
		upper=0
		[ -n "$bckfacename" ] && {
			facename="$bckfacename"
			unset bckfacename
		}
		return
	}
	
	[ "$word" = '<lp>' ] && {
		s+=('')
		pad=3
		skip_next_space=1
		return
	}
	((pad==3)) && {
		case "$word" in
			'&s'|'&space'|'<s>') padchar=' ';;
			'&'*) padchar="${resources[${word:1}]}";;
			*) padchar="$word"
		esac
		pad=2
		skip_next_space=1
		return
	}
	((pad==2)) && {
		expression="$word"
		pad=1
		return
	}
	[ "$word" = '</lp>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		local -i x="${bf_d[size-x]}"
		padnum=$(($expression))
		for ((; padnum>0; padnum--)); do
			face-no-expand "${facename:-${bf_d[background]:-default}}" "$padchar"
			bf_e[line]+='s'
		done						
		pad=0
		local wordspace=' '
		for ((pli=0; pli<${#padlist[@]}; pli+=2)); do
			((pli+2==${#padlist[@]})) && {
				wordspace=''
			}	
			face "${padlist[pli]}" "${padlist[pli+1]}${wordspace}"
		done
		padlist=()
		return
	}
	
	[ "$word" = '<h1>' ] || [ "$word" = '<h2>' ] || [ "$word" = '<subh1>' ] && {
		s+=('')
		pad=1
		skip_next_space=1
		return
	}
	[ "$word" = '</subh1>' ] && {
		for ((padnum= bf_d[size-x] / 2 - s[-1] / 2; padnum>0; padnum--)); do
			face-no-expand "${facename:-${bf_d[background]:-default}}" " "
			bf_e[line]+='s'
		done						
		pad=0
		local wordspace=' '
		for ((pli=0; pli<${#padlist[@]}; pli+=2)); do
			((pli+2==${#padlist[@]})) && {
				wordspace=''
			}	
			face "${facename:-unknown}" "${padlist[pli+1]}${wordspace}"
		done
		padlist=()
		return
	}
	
	[ "$word" = '</h1>' ] && {
		for ((padnum= bf_d[size-x] / 2 - s[-1] / 2; padnum>0; padnum--)); do
			face-no-expand divider "${resources[line]}"
			bf_e[line]+='s'
		done						
		pad=0
		local wordspace=' '
		for ((pli=0; pli<${#padlist[@]}; pli+=2)); do
			((pli+2==${#padlist[@]})) && {
				wordspace=''
			}	
			face title "${padlist[pli+1]^^}${wordspace}"
		done
		for ((padnum= bf_d[size-x] / 2 - s[-1] / 2; padnum>0; padnum--)); do
			face-no-expand divider "${resources[line]}"
			bf_e[line]+='s'
		done
		padlist=()
		return
	}
	
	[ "$word" = '</h2>' ] && {
		for ((padnum= bf_d[size-x] / 2 - s[-1] / 2; padnum>0; padnum--)); do
			face-no-expand "${facename:-${bf_d[background]:-default}}" " "
			bf_e[line]+='s'
		done						
		pad=0
		local wordspace=' '
		for ((pli=0; pli<${#padlist[@]}; pli+=2)); do
			((pli+2==${#padlist[@]})) && {
				wordspace=''
			}	
			face title "${padlist[pli+1]^^}${wordspace}"
		done
		padlist=()
		return
	}
	

	[ "$word" = '<>' ] && {
		unset linearray[-1]
		bf_e[line]=${bf_e[line]::-1}
		skip_next_space=1
		return
	}

	[ "$word" = '<hr>' ] && {
		for ((x=bf_d[size-x]; x>0; x--)); do
			face-no-expand "${facename:-divider}" "${resources[line]}"
			bf_e[line]+='s'
		done
		skip_next_space=1
		return		
	}
	
	((space_next==1)) && {
		space_next=0
		skip_next_space=1
		for ((if=0; if< word; if++)) {
			linearray+=(' ')
			bf_e[line]+='s'
			((column++))
		}
		return
	}
	[ "$word" = '<s>' ] && {
		space_next=1
		skip_next_space=1
		return
	}
	
	[ "$word" = '<ol>' ] && {
		listcount=1
		orderlist=1
		skip_next_space=1
		return
	}
	[ "$word" = '</ol>' ] && {
		listcount=0
		orderlist=0
		skip_next_space=1
		return
	}
	
	[ "$word" = '<li>' ] && {
		((orderlist==1)) && {
			word="${listcount}${resources[item-number]}"
			((listcount++))
		} || word="${resources[item]}"
	}
	
	[[ "$word" == '&'* ]] && word="${resources[${word:1}]}"
	((newline==1)) && newline=0
	((column+=${#bf_t[ichar]} + ${#word}))
	((upper==1)) && {
		word="${word^^}"
	}
	((pad==1)) && {
		padlist+=(
			"${facename:-unknown}" "${bf_t[ichar]}$word"
		)
		s[-1]=$((s[-1] + ${#word} + 1))
		skip_next_space=1
		return
	}
	face-no-expand "${bf_t[indent_spaces_f]:-tab}" "${bf_t[ichar]}"
	bf_e[line]+="${bf_t[iexp]}"
	face "${facename:-unknown}" "$word"
}

function link-enter {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"		
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				has=1
				${bf_c_line[exec]}
				return
			}
	}
	${bf_d[format-else]}
}

function format-left {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[left]:-backward-char}
				return
			}
	}
	backward-char
}
function format-up {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[up]:-previous-line}
				return
			}
	}
	previous-line
}
function format-right {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[right]:-forward-char}
				return
			}
	}
	forward-char
}
function format-down {
	for link in ${bf_c[bf_d[line]]}; {
		local -n bf_c_line="$link"
		((bf_d[column] >= bf_c_line[start])) &&
			((bf_d[column] <= bf_c_line[end])) && {
				${bf_c_line[down]:-next-line}
				return
			}
	}
	next-line
}

function obj {
	for y in "${!bf_c[@]}"; {
		for obj in ${bf_c[y]}; {
			local -n bf_c_line="$obj"
			[ "${bf_c_line[id]}" = "$1 " ] && {
				((bf_d[line]=y, bf_d[column]=bf_c_line[start]))
				redraw.cursor
			}
		}
	}
}

function toggle-checkbox {
	local -n var="$2"
	case "$var" in
		0) var=1;;
		*) var=0
	esac
	make-render-line "$1"
	redraw
}
########################################################################################################################

fn is-function 'declare -F -- "$1" > /dev/null'

## Dumps current buffer into a file	
function dump-buffer {
	true >"$1" # Set the file to an empty text file
	for ln in "${buffer[@]}"; do # Write in the buffer to the file
		echo "$ln" >>"$1"
	done
}

## die
# Closes Ebashs with exit code \$errno, if errno is empty exit with 0
# If \$nocleanup is 1, do not restore the terminal to sane mode and do not cleanup 
# Else restore to sane mode 
function die {
	((nocleanup)) && exit "${errno:-0}"
	echo -e "\e[?1000;1006;1015l" #disable mouse tracking
	clear-screen # TODO fix the buffer switching
	printf '\e[?25h\e[?7h\e[?1049l' # Reset terminal to sane mode
	global-hook die
	exit "${errno:-0}" # Assume that we are exiting without an error
}

# Sets \$nocleanup to 1 and dies	
function die.force {
	((nocleanup=1)) && die "$@"
}

function move.previous-line.check ((bf_d[line] > 1))
function move.next-line.check ((bf_d[line] < ${#buffer[@]}+bf_d[last-newline]))

# Moves up \$1 lines, if \$ is empty move up 1 line
function move.previous-line {
	for ((i = 0; i < ${1:-1}; i++)); do
		((bf_d[line] > 1)) && ((bf_d[line]--))
		((bf_d[line] < bf_d[base] + 1)) && {
			((bf_d[base]--)) # Push back the top if we need to
			move_base=1 # Send signal to redraw.cursor that the buffer was moved, thus needs to be redraw fully
			((bf_d[base] <= 0)) && bf_d[base]=1 # Don't push back if our base is at 1
		}
		[ -z "$bckrl" ] && bckrl="${bf_d[column]}"	
		(( ${#bf_e[bf_d[line]]} < bf_d[column] )) && bf_d[column]=${#bf_e[bf_d[line]]}
		(( ${#bf_e[bf_d[line]]} > bckrl )) && bf_d[column]=${bckrl}
	done
}

# Moves down \$1 lines, if \$ is empty move down 1 line
function move.next-line {
	for ((i = 0; i < ${1:-1}; i++)); do
		((bf_d[line] < ${#buffer[@]}+bf_d[last-newline])) && ((bf_d[line]++))
		# Move window down if needed
		((bf_d[line] > bf_d[base] + bf_d[size-y] - 3)) && {
			((bf_d[base]++))
			move_base=1
		}
		[ -z "$bckrl" ] && bckrl="${bf_d[column]}"	
		(( ${#bf_e[bf_d[line]]} < bf_d[column] )) && bf_d[column]=${#bf_e[bf_d[line]]}
		(( ${#bf_e[bf_d[line]]} > bckrl )) && bf_d[column]=${bckrl}
	done
}

function previous-line {
	move.previous-line.check || return
	hook pre-move
	move.previous-line "$@"
	hook move
	redraw.cursor
}
function next-line {
	move.next-line.check || return
	hook pre-move
	move.next-line "$@"
	hook move
	redraw.cursor
}
function scroll-down {
	hook pre-move
	move.previous-line $((bf_d[size-y] - 3))
	hook move
	redraw.cursor
}
function scroll-up {
	hook pre-move
	move.next-line $((bf_d[size-y] - 3))
	hook move
	redraw.cursor
}
	
fn move-beginning-of-line 'bf_d[column]=0; redraw'
fn move-end-of-line 'bf_d[column]="${#bf_e[${bf_d[line]}]}"; redraw'

function forward-char {
	for ((i = 0; i < ${1:-1}; i++)); do
		case "${bf_e[${bf_d[line]}]:${bf_d[column]}+1:1}" in
			't') bf_d[column]=$(( bf_d[column]+${#resources[tab]}));;
			*) ((bf_d[column]++));;
		esac
		((bf_d[column] > ${#bf_e[${bf_d[line]}]})) && {
			bf_d[column]=0
			next-line
			return
		}
		bckrl=
	done
	if ((bf_d[selection])); then
		redraw
	else
		redraw-line.cursor
	fi
}

function backward-char {
	for ((i = 0; i < ${1:-1}; i++)); do
		case "${bf_e[${bf_d[line]}]:${bf_d[column]}-1:1}" in
			't') bf_d[column]=$(( bf_d[column]-${#resources[tab]}));;
			*) ((bf_d[column]--));;
		esac
		((bf_d[column] < 0)) && ((bf_d[line]==1)) && {
			bf_d[line]=1
			bf_d[column]=0
		}
		((bf_d[column] < 0)) && {
			bf_d[column]="${#bf_e[${bf_d[line]}-1]}"
			previous-line
			return
		}
		bckrl=
	done
	if ((bf_d[selection])); then
		redraw
	else
		redraw-line.cursor
	fi
}
	
## forward-word
# Moves forward to next word
function forward-word {
	((bf_d[column] == ${#bf_e[bf_d[line]]})) && {
		next-line
		move-beginning-of-line
	}
	while :; do
		((bf_d[column] < ${#bf_e[bf_d[line]]})) && ((bf_d[column]++)) || break
		case "${bf_e[bf_d[line]]:${bf_d[column]}:1}" in
			't'|'s') break
		esac
	done
	redraw
}

## backward-word
# Moves backward to previous word
function backward-word {
	((bf_d[column] == 0)) && {
		previous-line
		move-end-of-line
	}
	while :; do
		((bf_d[column] > 0)) && ((bf_d[column]--)) || break
		case "${bf_e[bf_d[line]]:${bf_d[column]}:1}" in
			't'|'s') break
		esac
	done
	redraw
}


#Move cursor to line number $1 and move the line into middle of visible buffer area.
function to-line {
	bf_d[line]="$1"
	bf_d[base]=$((bf_d[line] - bf_d[size-y] / 2 ))
	redraw
}

# Redraw popup menu
function redraw.menu {
	printf '\e[?25l' # hide cursor (again)
	printf '\e[%s;0H' "${bf_d[line]}" #$menuloc_y
	for i in "${!menu_0[@]}"; {
		if ((i == menuselection)); then
			printf "\e[%sC%b%s${reset}\n" "${bf_d[column]}" "${faces[menu-selected]}${faces_raw[${menu_2[i]:-menu-selected}]}" "${menu_0[i]}"
		else
			printf "\e[%sC%b%s${reset}\n" "${bf_d[column]}" "${faces[menu-enabled]}${faces_raw[${menu_2[i]:-menu-enabled}]}" "${menu_0[i]}"
		fi
	}
}


function menu.up {
	((menuselection > 0)) && ((menuselection--));
	redraw.menu;
}
function menu.down {
	((menuselection < ${#menu_0[@]} -1)) && ((menuselection++));
	redraw.menu;
}

# Execute selected item in menu
function menu.select
for i in "${!menu_1[@]}"; {
	((i == menuselection)) && ${menu_1[i]}
}

# Closes a menu
function menu.exit {
	ismenu=0
	bf_d[mode]="${modebackup}"
	redraw
}

# Opens a menu \$1	
function menu {
	declare -ng menu_0=menu_${1}_0
	declare -ng menu_1=menu_${1}_1
	declare -ng menu_1=menu_${1}_2
	((ismenu == 0 )) && modebackup="${bf_d[mode]}"
	ismenu=1
	declare -ig menuselection=0
	bf_d[mode]='menu'
	redraw
}

# deletes current buffer
function delete-buffer {
	local -a copy
	local i=0
	local index
	for b in "${buffers_l[@]}"
	do
		[[ "$b" != "$current_buffer"  ]] && copy+=("$b")
		[[ "$b" = "$current_buffer"  ]] && index="$i"
		((i++))
	done
	unset buffers_l
	copy-array copy buffers_l
	current_buffer="${buffers_l[index-1]}"
	redraw
}

# Handle changing size of terminal
function change-size-screen {
	bf_d[size-x]="$COLUMNS"
	bf_d[size-y]=$((LINES-1))
	redraw
}
	
## redraw
# Redraw screen
function redraw {
	@hook begin && return
	redraw.content
	redraw.cursor
}

## hooks
# stored in bf_h ass. array
# naming scheme is '<function> <name>', function name is handled automatically when defining a hook via @hook
function @hook {
	local name="${FUNCNAME[1]} $1"
	shift
	[ -n "${bf_h[${name}]}" ] && {
		${bf_h[${name}]} "$@"
		return 0
	}
	return 1
}
# common hooks, without function prefix
function hook {
	local name="$1"
	shift
	[ -n "${bf_h[${name}]}" ] && {
		${bf_h[${name}]} "$@"
		return 0
	}
	return 1
}
# global hooks, shared in every buffer
function global-hook {
	local name="$1"
	shift
	[ -n "${hooks[${name}]}" ] && {
		${hooks[${name}]} "$@"
		return 0
	}
	return 1
}


function linenum.begin {
	# Get length of line-number of lines
	bf_d[length]="${#buffer[@]}"
	((bf_d[length]==0)) &&((bf_d[length]++))
	
	bf_d[number-length]=${#bf_d[length]}
	bf_d[number-space]=1
}
function linenum.loop-begin {
	space=1
	ln="\e[%dG%b%*s"
	lnargs=(
		"${bf_d[loc-x]}"
		"${faces[line-number]}"
		"${bf_d[number-length]}"
		"$i"
	)
	((i == bf_d[line])) && lnargs[1]="${faces[line-number-current-line]}"
}
function linenum.update {
	printf '\e[%s;%sH%b%*s\e[m'\
		   $((last_line + options[menu-line] - bf_d[base] + bf_d[loc-y]))\
		   "${bf_d[loc-x]}"\
		   "${faces[line-number]}"\
		   ${bf_d[number-length]}\
		   $last_line
	printf '\e[%s;%sH%b%*s\e[m'\
		   $y\
		   "${bf_d[loc-x]}"\
		   "${faces[line-number-current-line]}"\
		   ${bf_d[number-length]}\
		   ${bf_d[line]}
}

function set-linenum {
	bf_h[redraw.content begin]=linenum.begin
	bf_h[redraw.content loop-begin]=linenum.loop-begin
	bf_h[redraw.cursor pre-redraw]=linenum.update
}
function unset-linenum {
	bf_h[redraw.content begin]=''
	bf_h[redraw.content loop-begin]=''
	bf_h[redraw.cursor pre-redraw]=''
}

function redraw.content {
	printf '\e[?25l'
	
	# the first line should be always empty 
	unset buffer[0]

	((bf_d[number-length]=0, bf_d[number-space]=0))
	
	@hook begin
	
	# Move the buffer horizontally if needed
	((bf_d[column] +3 < bf_d[size-x] - bf_d[number-length] - 1)) &&
		bf_d[basecolumn]=0
	((bf_d[column] +3 > bf_d[size-x] - bf_d[number-length] - 1)) &&
		bf_d[basecolumn]=$((bf_d[column] - (bf_d[size-x] + bf_d[loc-x] - bf_d[number-length] - 1) +3))

	printf "\e[%s;%sH" "${bf_d[loc-y]}" "${bf_d[loc-x]}"
	
	# IFS has to be empty in order to bufferarray multiarray be printed as words instead of chars
	IFS=''

	# Handle line number displaying
	# the resulting line has to be printed in one go to prevent flicker
	# space stores if the position of actuall text should be offset by +1
	# ln stores printf print line
	# args stores printf arguments
	local -i space
	local ln
	local -a lnargs
	
	# Iterate over shown lines
	local -i max=$((bf_d[size-y]))
	for ((i = bf_d[base]; i - bf_d[base] < max; i++)); do
	# if the line is last, do not add newline

		ln="\e[%dG"
		lnargs=(
			"${bf_d[loc-x]}"
		)
		@hook loop-begin
		
		((i - bf_d[base] > max - 2)) && nlchar='' || nlchar='\n'

		((i > ${#buffer[@]})) &&
			printf '%b\e[%d;%dH%*s'\
				   "${faces[${bf_d[background]:-default}]}"\
				   $((bf_d[loc-y]+i-1))\
				   "${bf_d[loc-x]}"\
				   $((bf_d[size-x] - bf_d[number-length]))\
				   ''\
				&& continue
		
		# to improve speed syntaxing has to be "lazy" -- having to be heavily cached as ram is far less expensive to waste
		[ -z "${bf_s[base+i]}" ] && {
			make-render-line $((base + i))
		}
		local -n linearray="${bf_s[i]}"
		
		# due to escape codes present in bf_s,
		# the bf_s has to be multidimensional nonsense for perfomance reasons
		printf "${ln}%b%*s\e[%sG%b%s\e[m%b"\
			   ${lnargs[@]}\
			   "${faces[${bf_d[background]:-default}]}"\
			   $((bf_d[size-x] - bf_d[number-length]))\
			   ''\
			   $((bf_d[loc-x] + bf_d[number-length] + space))\
			   "${faces[${bf_d[background]:-default}]}"\
			   "${linearray[*]:bf_d[basecolumn]:bf_d[size-x] - (bf_d[number-length])}"\
			   "$nlchar"
	done
	@ifs
	# redraw menu if open
	[ "${bf_d[mode]}" = 'menu' ] && redraw.menu
}



## print-buffer-line
function print-buffer-line {
	IFS=''
	# why this errors when stderr is redirected
	local -n linearray="${bf_s[bf_d[line]]}"
	printf '%s' "${linearray[*]:bf_d[basecolumn]:bf_d[size-x] - (bf_d[number-length])}"
	@ifs
}

# Draw cursor on the line
function redraw-line.cursor {
	((options[full-redraw]==0)) && {
		# redraw if buffer needs to be moved horizontally
		((bf_d[column] > bf_d[size-x] - bf_d[number-lenght] - space)) && {
			redraw
			return
		}
		((bf_d[basecolumn]==0)) || {
			redraw
			return
		}
		printf '\e[%sG\e[?25h'\
			   $((bf_d[column] - bf_d[basecolumn] + bf_d[number-length] + bf_d[loc-x] + bf_d[number-space])) ||
			redraw
	}
}
	
# Draw cursor and if move_base is 1 redraw
function redraw.cursor {
	@hook first && return
	((move_base)) && {
		move_base=0
		redraw
		return
	}
	local -i y=$((bf_d[line] + options[menu-line] - bf_d[base] + bf_d[loc-y]))
	@hook pre-redraw
	printf '\e[%s;%sH\e[?25h'\
		   $y\
		   $((bf_d[column] - bf_d[basecolumn] + bf_d[number-length] + bf_d[loc-x] + bf_d[number-space]))
	last_line=${bf_d[line]}
	@hook post-redraw
}

function cursor.hide {
	printf '\e[?25l'
}
function cursor.show {
	printf '\e[?25h'
}

## keypress.mouse
# Handle mouse click
function keypress.mouse {
	local -i x y
	#parse mouse stuff somewhatish weirdly
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 36 34' ] && previous-line && return
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 36 35' ] && next-line && return
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 38 30' ] && previous-line 9 && return
	[ "${k_hex[*]:0:5}" = '1b 5b 3c 38 31' ] && next-line 9 && return
	((skipnext==1)) && skipnext=0 && return
	((skipnext==0)) && [ "${k_hex[*]:0:2}" = '1b 5b' ] && {
		mapfile -t -d '' inputarray <<< "${1}"
		inputarray[-1]="${inputarray[-1]%?}"
		[ -z "${inputarray[2]}" ] && skipnext=1
		mapfile -t -d ';' inputarray <<< "${inputarray[1]}"
		inputarray[-1]="${inputarray[-1]%?}"	
		mousemode="${inputarray[0]}"
		x="${inputarray[1]}"
		y="${inputarray[2]::-1}"
		#limitations of movenment
		#TODO:
		((x < (bf_d[number-length] + bf_d[loc-x] + 2))) && {
			if [ "$mousemode" = '[<0' ]; then
				bf_d[line]=$(( bf_d[base] + (y - bf_d[loc-y]) ))
				redraw
			elif [ "$mousemode" = '[<2' ]; then #VERY BAD SOLUTION, TODO: FIX
				clear-screen
				echo 'Enter the index: '
				read -re line
				redraw
			fi
			return
		}
		bf_d[line]=$(( bf_d[base] + ( y - bf_d[loc-y] - 1) ))
		bf_d[column]=$(( x - (bf_d[loc-x] + bf_d[number-length] + 1) ))
		((bf_d[line] > ${#bf_e[@]})) &&
			bf_d[line]=${#bf_e[@]}
		((bf_d[column] > ${#bf_e[bf_d[line]]})) &&
			bf_d[column]=${#bf_e[bf_d[line]]}
		redraw
	}
}

## insert-word
# Insert \$1 to buffer
function insert-word {
	local -i rlr
	unset ta
	local ta
	ta=${bf_e[${bf_d[line]}]:0:${bf_d[column]}}
	ta=${ta//[^t]}
	ta=${#ta}
	rlr=$((bf_d[column] + ta / 4 - ta))
	buffer[bf_d[line]]="${buffer[${bf_d[line]}]:0:${rlr}}$1${buffer[${bf_d[line]}]:${rlr}}"
	#add at cursor position - amount of tabs * tab size
	make-render-line
	forward-char "${#1}"
	bf_d[selection]=0
	redraw
	bf_d[modified]=1
}

## keypress Handles input
# Either \$1 raw character input or k_hex array containing hex values of characters is used
function keypress {
	#arg $1 is the pressed key in normal text form
	#k_hex is pressed key in hex array ending with 0
		
	local -i mode_contains=0
	local -n modekeys="keys_${bf_d[mode]}"\
	         key_options="key_options_${bf_d[mode]}"

	# global keys
	((key_options[disable-global])) ||
		for str in "${!keys_global[@]}"
		{
			[ "$str" = "${k_hex[*]}" ] && {
				"${keys_global[$str]}"
				return
			}
		}

	# Execute the 'always' key option
	((${#key_options[@]})) &&
		[ -n "${key_options[always]}" ] && "${key_options[always]}"

	# Loop over current mode keybindings to match current keypress
	for str in "${!modekeys[@]}"
	{
		[ "$str" = "${k_hex[*]}" ] && {
			"${modekeys[$str]}"
			mode_contains=1
		}
	}

	# If mode keybinding doesn't contain current keypress, execute this
	((${#key_options[@]})) &&
		((mode_contains == 0)) &&
		[ -n "${key_options[else]}" ] && {
			[ "${key_options[else]}" = 'insert' ] || {
				"${key_options[else]}" && return
			}
		}

	# Do not continue if mode contains keypress to prevent control chars flooding file
	((mode_contains==1)) && return

	# If mouse is enabled, do whatever the hell that ugly piece of code does
	(("${options[mouse]}"==1)) && {
		keypress.mouse "$1"
		return
	}

	# Insert the pressed character
	[[ $1 =~ [[:cntrl:]] ]] && return # If char is control char, return
	insert-word "$1"
}

function init-var {
	trap change-size-screen WINCH ALRM # Attach WINCH and ALRM to redraw the screen
	trap die EXIT HUP USR1 # Attach most exit codes to cleanup and exit
	trap 'k_hex=(3 0); keypress' INT
	trap quit SIGTERM

	format_tab=4
	reset='\e[0;0m'
	charmap=(
		#[0] is reserved for any unmapped char
		[	]='t' # tab
		[ ]='s' # space
	)
	if ((options[esc-to-meta])); then
		esc_timeout=123456789 # a very big number
	else
		esc_timeout=0.01
	fi
	nlchar='\n'
	printf '\e[?1049h'
	((options[mouse])) && echo -ne "\e[?1000;1006;1015h" #enable mouse tracking
}

## main Main keyboard loop
function input-loop
	while :; do
		local -a k=()
		local -i i=1
		k_hex=() # Also convert the input sequence into hex for way easier handling
		# Check for ready input
		read -rsN1 k[0] && {
			k_hex[0]="$(printf "%x\n" "'${k[0]}")"

			# Hack to try preventing arrow codes being split into multiple and inserting garbage to buffer
			[ "${k_hex[0]}" = '1b' ] && {
				read -rsN1 -t "${esc_timeout}" k[1]
				k_hex[1]="$(printf "%x\n" "'${k[1]}")"
				[ "${k_hex[1]}" = '5b' ] && {
					read -rsN1 k[2]
					k_hex[2]="$(printf "%x\n" "'${k[2]}")"
					case "${k_hex[2]}" in
						'41'|'42'|'43'|'44')
							k_hex[3]='0'
							keypress "${k[@]}"
							continue
					esac
					i=2
				}
				((i++))
			}
			# Multibyte hack
			while read -rsN1 -t0.0001 k[$i]; do
				k_hex[$i]="$(printf "%x\n" "'${k[$i]}")"
				((i++))
			done
			k_hex[$i]='0'
			keypress "${k[@]}" # Handle keypress event
		}
	done

### INCLUDED BUFFERS

function about {
	declare-buffer about
	bf_d+=(
		[mode]=basic
		[syntax]=syntax-format
		[syntax-exec]=1
		[render-type]=per-char
	)
	buffer=(
		''
		'<h1> About Buffermaker </h1>'
		''
		'Buffermaker version: <f> hint <v> buffermaker_version </f>'
		'Bash version: <f> hint <v> BASH_VERSION </f>'
		'Terminal: <f> hint <v> TERM </f>'
		''
		'<hr>'
		''
		'Aeknt 2022-2024'
		'Repo: https://github.com/aeknt/BufferMaker' 
		'(Based on Bed https://github.com/comfies/bed Comfies 2020)'
		''
		'<h3> Licence </h3> <f> yellow (BSD-0) </f>'
		'Permission to use, copy, modify, and/or distribute this software for any purpose'
		'with or without fee is hereby granted.'
		''
		'THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD'
		'TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.'
		'IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,'
		'OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA'
		'OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,'
		'ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.'
		''
		'<o> id: quit select: die text: <f> button quit </f> </o>'
	)
	load-default-config
	init-var
	redraw
	obj quit
	input-loop
}

function box.shadow {
	bf_d+=(
		[size-y]=${size_y}
		[loc-y]=${loc_y}
		[size-x]=${size_x}
		[loc-x]=${loc_x}
	)

	declare-buffer msgbox_background
	bf_d+=(
		[mode]=none
		[syntax]=syntax-none
		[syntax-exec]=0
		[render-type]=per-word
		[background]=border-highlight

		[size-y]=$((size_y + 2))
		[loc-y]=$((loc_y - 1))
		[size-x]=$((size_x + 2))
		[loc-x]=$((loc_x - 1))
	)
	redraw

	declare-buffer msgbox_shadow
	bf_d+=(
		[mode]=none
		[syntax]=syntax-none
		[syntax-exec]=0
		[render-type]=per-word
		[background]=border-shadow

		[size-y]=$((size_y + 1))
		[loc-y]=$((loc_y))
		[size-x]=$((size_x + 1))
		[loc-x]=$((loc_x))
	)
	redraw
}

function msgbox {
	local return_to="${current_buffer}"
	local -n message="${1}"
	local -n message_title="${1}_title"
	declare-buffer msgbox
	bf_d+=(
		[mode]=basic
		[syntax]=syntax-format
		[syntax-exec]=1
		[render-type]=per-char
		[return-to]="${return_to}"
	)
	buffer=(
		''
		''
		"<h2> ${message_title} </h2>"
		''
	)
	append-array message buffer
	buffer+=(
		''
		'<s> 14 <f> hint <Enter> </f> <o> id: ok select: box.close right: : left: : up: : down: : text: <f> button  Ok  </f> </o>'
	)
	
	local size_y=$((${#buffer[@]}))
	local loc_y=$((LINES / 2 - ( ${#buffer[@]} - 1 ) / 2 ))
	local size_x=40
	local loc_x=$((COLUMNS / 2 - 20))

	box.shadow
	
	set-buffer msgbox
	redraw
	obj ok
}

function dialogbox {
	local return_to="${current_buffer}"
	local -n message="${1}"
	local -n message_title="${1}_title"
	declare-buffer dialogbox
	bf_d+=(
		[mode]=basic
		[syntax]=syntax-format
		[syntax-exec]=1
		[render-type]=per-char
		[return-to]="${return_to}"
	)
	buffer=(
		''
		''
		"<h2> ${message_title} </h2>"
		''
	)
	append-array message buffer
	buffer+=(
		''
		'<s> 2 '\
"<o> id: yes select: ${1}.yes right: obj no left: : up: : down: : text: <f> button  Yes  </f> </o> "\
"<o> id: no select: ${1}.no right: : left: obj yes up: : down: : text: <f> button  No  </f> </o>"
	)
	
	local size_y=$((${#buffer[@]}))
	local loc_y=$((LINES / 2 - ( ${#buffer[@]} - 1 ) / 2 ))
	local size_x=40
	local loc_x=$((COLUMNS / 2 - 20))
		
	bf_d+=(
		[size-y]=${size_y}
		[loc-y]=${loc_y}
		[size-x]=${size_x}
		[loc-x]=${loc_x}
	)

	box.shadow
	
	set-buffer dialogbox
	redraw
	obj no
}

function box.close {
	set-buffer "${bf_d[return-to]}"
	redraw
}

[[ "${BASH_SOURCE[0]}" = "${0}" ]] && about
